\documentclass{beamer}
\usetheme{CambridgeUS}
\usepackage{algorithm,algpseudocode}
\usepackage{lmodern, mathtools}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}


\title{SC2001 Project 3}
\subtitle{Dynamic Programming}
\author[Hong, Dinh, He]{Hong Jia Yang \and Dinh Pham Minh Anh \and He Qi Xin}
\institute{Team 4}
\date{\today}

\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\frametitle{Outline}
	\tableofcontents
\end{frame}

\section{Environment Specifications}
\begin{frame}
	\frametitle{Environment}
	\begin{itemize}
		\item Software
		\begin{itemize}
			\item C++
			\item MinGW g++ 13.1.0	
			\item Header \texttt{<bits/std++.h>} 
		\end{itemize}
		\item Hardware
		\begin{itemize}
			\item OS: Windows 11 (Home) x86\_64
			\item Processor: Intel(R) Core(TM) i7-10750H (12) @ 2.59 GHz
		\end{itemize}	
	\end{itemize}
	\begin{block}{Note}
		Please refer to \texttt{JamesRobertJohns/team4project3}
	\end{block}
\end{frame}

\section{Recursive Definition}
\subsection{Problem Analysis}
\begin{frame}
	\frametitle{Read the Problem}
	\begin{itemize}
		\item Given a knapsack of capacity of \( C \) weight and \( n \) types of objects, where
	\(
		C, n \in \mathbb{Z}^+
	\)
	\item The \( i^{th} \) object has weight \( w_i \) and profit \( p_i \), where 
		\(
			w_i, p_i \in \mathbb{Z}^+
		\)
		\begin{itemize}
			\item This makes the problem simpler 
			\item If values can be negative, we can displace the terms by \( - min(\{w_i\}) \) and \( - min(\{p_i\}) \) correspondingly such that they become \emph{non-negative} 
			\item The optimal filling will be the same, but optimal value will be adjusted accordingly
		\end{itemize}	
	\item There are \emph{unlimited} supplies of each type of objects
		\begin{itemize}
			\item \textbf{Unbounded} - We can use the object more than once
			\item Similar concept in Coin Change II 
		\end{itemize}	
	\item Find the \emph{largest} total profit of any set of the object that fits in the knapsack
		\begin{itemize}
			\item Greedy doesn't work - consider any counter example
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection{Intuition}
\begin{frame}
	
\end{frame}

\subsection{Formal Definition}
\begin{frame}
	
\end{frame}

\section{Sub-problem Graph}
\begin{frame}
	
\end{frame}

\section{Algorithm}
\begin{frame}
	
\end{frame}
\subsection{Pesudo code}
\begin{frame}
	
\end{frame}

\subsection{Implementation}
\begin{frame}
	\frametitle{2D Array}
  \lstinputlisting[language=C++]{asset/dp.cpp}
\end{frame}

\begin{frame}
	\frametitle{1D Array}
  \lstinputlisting[language=C++]{asset/dpp.cpp}
\end{frame}

\begin{frame}
  \frametitle{IO specification}
  Let the input be \texttt{.text} files, such that the first line is capacity $C$, and second line is number of objects $n$. The third and fourth lines are the respective values of $w_i$ and $p_i$  for the $i^{th}$ object, space delimited
  \begin{itemize}
    \item Test case 1 can be represented as \newline
        14\newline
        3\newline
        4 6 8\newline
        7 6 9\newline
    \item Test case 2 can be represented as \newline
        14\newline
        3\newline
        5 6 8\newline
        7 6 9\newline
  \end{itemize}
\end{frame}

\begin{frame}
	\frametitle{main}
  \lstinputlisting[language=C++]{asset/main.cpp}
\end{frame}

\begin{frame}
  \frametitle{output}
  \begin{itemize}
    \item Output of \texttt{./a < ../data/input1.txt}
      \begin{itemize}
        \item 21
      \end{itemize}
    \item Output of \texttt{./a < ../data/input2.txt}
      \begin{itemize}
        \item 16 
      \end{itemize}
  \end{itemize}
\end{frame}

\end{document}
